# Nana - a backend framework

> Note form author (Harlos): Below text is generated by ChatGPT based on the conversation between us. Information is not verified and may not be accurate. Please use it as a reference only.

> conversation link: https://chatgpt.com/share/686b4ef2-741c-8000-8c01-6b71f7341144

## Project Summary

This project is a custom Node.js backend framework inspired by Nuxt/Next-style file-based routing, built on top of Express but designed to be minimal, flexible, and type-safe.

The goal is to provide a better developer experience than raw Express (which requires boilerplate) and more flexibility than NestJS (which can be overly opinionated and complex). It allows for file-based routing, modular controller/middleware composition, and runtime-typed context propagation â€” all while remaining lightweight and highly extensible.

---

## Design Philosophy

- **Type-safe context flow**: Middleware and controllers propagate strongly-typed context generics, allowing hierarchical data enrichment.
- **Composable routing**: Routing is organized as a hierarchy of middleware and controllers, supporting both file-based and programmatic use.
- **Built on Express**: Internally uses Express router, keeping compatibility and performance benefits while hiding boilerplate.
- **Customizable flow**: Developers can override controller action, error handling, and optionally plug in response transformers, redirect logic, etc.
- **Post-handler concept**: Middleware can define post-processing logic (`postHandler`) that runs after the main execution regardless of outcome.

---

## Current Status

### âœ… Implemented

- `NanaServerApp`: Application root
- `NanaMiddleware`: Express-style middleware with context injection
- `NanaController`: Method-based controller endpoint with typed handler
- Default implementations of:
  - `controllerAction`: sends response body and status
  - `errorHandler`: handles exceptions and logs errors
- Middleware and controller routing via `.get`, `.post`, etc. (Express method binding)
- Inheritance of typing and control flow through parent-child relationships
- Uses `res.locals.body` for optional logging

### ðŸ§ª Testing Approach

- TDD-friendly structure using **Vitest**
- Supports Supertest for integration testing
- Plan is to unit-test:
  - File loader (for file-based routing)
  - Route matcher (for dynamic `[param]` style support)
  - Execution chain (middleware â†’ controller â†’ post handler)

---

## Next Steps

- Create a test setup with `Supertest` and `Vitest` to validate routing flow
- Integrate file-based route loader (matching `[id].get.ts`, etc.)
- Integrate matcher using `path-to-regexp` for param parsing
- Write handler runner to glue routes, middleware, and controller logic
- Eventually add:
  - Plugins (OAuth2, session, rate-limit, logging)
  - CRUD generators (`index.crud.ts`)
  - API doc + TS type generation
  - Optional decorators and lower-level API access

---

## Key Principles

- Provide high DX with minimal boilerplate
- Allow multiple usage modes (file-based, programmatic, domain-logic-driven)
- Expose low-level primitives to avoid "too much magic"
- Make error and response behavior consistent and customizable
- Embrace modularity and developer control

